Общие положения:
* Система состоит из 2 компонентов: FPGA и R.Pi Zero 2w
* FPGA принимает 64x64 изображение в буфер, отвечает за его выдачу на дисплей и имеет возможность смены кадра на "негатив" по заданному таймеру
* RPi отвечает за все прочие функции и общается с FPGA через односторонний (M->S) SPI интерфейс

# Аппаратная часть, FPGA

Схема работы FPGA:

Коммуникатор SPI\
|	V\
|  BRAM 64x64 Красный\
|  BRAM 64x64 Зеленый\
|  BRAM 64x64 Синий\
V   |    A\
BRAM 64 Регистр управления\
|	|    |\
Маскировщик\
|   V    A	\
|	Корректор\
|	V    A\
Считыватель строки\
  |\
Записыватель строки\
  |\
Дисплей\

## Коммуникатор SPI
К коммуникатору SPI подключены 4 входа: SCLK, CE (выбор устройства), MOSI и ALT. Все, кроме последнего, являются частями SPI.
Коммуникатор пишет данные в ОЗУ транзакциями по 64 бита, меняя адреса по типу "кольцевого буфера" (1, 2, 3, n, 1, 2...). 
При низком уровне ALT записываются адреса красного (64) -> зеленого (64) -> синего (64) буферов (всего 192 транзакции до повтора). Первому и последнему входящему биту соответствуют крайние углы матрицы, между ними биты вводятся построчно с возвратом в начало при переходе строки.

Пример выгрузки изображения на Python (+NumPy):
```
frame_r = np.full((64, 64), False, dtype=np.bool)
frame_g = np.full((64, 64), False, dtype=np.bool)
frame_b = np.full((64, 64), False, dtype=np.bool)

\# -- задание изображений, (0, 0) - левый верхний угол -- 

spi.writebytes2(list(np.packbits(frame_r).tobytes()))
spi.writebytes2(list(np.packbits(frame_g).tobytes()))
spi.writebytes2(list(np.packbits(frame_b).tobytes()))
```

При высоком уровне ALT записывается 64-битный регистр контроля. Регистр один, и перезаписывается каждой транзакцией. Формат регистра:
u8'яркость - u16'1й делитель - u16'2й делитель - 16'резерв - 8'акт. маскировщика

Пример программирования регистра дан в описании маскировщика

[Важно] Пин ALT также несет функцию синхронизатора - при передаче бита с определенным ALT (достаточно 1 бита, не полной транзакции) состояние записи противоположного буфера (при выс. ALT - изображение, при низком - регистр контроля) очищается и указатель возвращается в начальное положение. Если транзакция на этом буфере не завершилась (передано не 64 бита), она также сбрасывается и данные теряются.
Таким образом, если при передаче изображения нет уверенности в текущем положении указателя (какой ряд запишется следующим), можно установить пин ALT в высокое состояние и отправить 1 байт. Это не приведет к транзакции в регистр управления (передано менее 64 байт), но сбросит указатель изображения на первый пиксель крайнего левого угла. Если после этого начать запись изображения снова с низким значением ALT, это в свою очередь сбросит незавершенную транзакцию control регистра. Обратное так же верно.

Таким образом, рекомендуемая схема запуска и сброса устройства такова:

ALT <= 1;
SPI <= 8'b0; # сброс указателя изображения
ALT <= 0;
SPI <= 192'b0; # очистка буфера изображения + сброс транзакции в ctrl
... Остальные транзакции

Транзакции в ОЗУ и регистры обрабатываются с частотой 20 мгц, но состояние приемного регистра при транзакции не фиксируется, потому разрешение транзакции должно происходить до передачи следующего бита - не рекомендуется повышать частоту SPI более 10мгц

## Маскировщик
В норме, система передачи данных на дисплей считывает содержимое буфера изображения напрямую. В таком режиме она работает, если последние 8 бит ctrl регистра все не равны 1. Но если они равны, происходит активация маскировщика - он перехватывает читаемые значения и изменяет их. 
В основном это нужно для создания стробоскопического эффекта без постоянной перезаписи буфера через SPI. 

Маскировщик работает со значениями делителей из ctrl - при отключенном маскировщике они не имеют смысла. Включение маскировщика изменяет функции буферов:
R (красный, 1й) -> Always (всегда светлые пиксели)
G (зеленый, 2й) -> Never (всегда темные пиксели) 
B (синий, 3й) -> Switching (цвета меняются на противоположные каждый кадр)
Never имеет приоритет над Always, Always - над Switching

Делители задают частоту кадров смены цвета в Switching. Эти кадры никак не связаны с физической частотой обновления дисплея (она будет обсуждена далее). Они выполнены в виде последовательных 16-битных целочисленных делителей сигнала 8мгц (8мгц / дел. 1 / дел. 2), положительный фронт выходного сигнала переключает кадр.

__Важно__ Задаваемая делителями частота - это частота _смены_кадров_. То есть, за один период кадр меняется либо с негатива на позитив, либо наоборот. Чтобы получить частоту полного периода (от позитива до позитива), нужно поделить ее на 2
	* Платформа Игната считает именно полные периоды (позитив -> позитив), результат с этой будет расходиться в 2 раза

При включенном маскировщике платформа перейдет в монохромный режим и будет выдавать изображение цвета последнего буфера (по умолчанию красный). Это обусловлено тем, что акты чтения буферов идут последовательно, и только к последнему будет точно известен конечный вид изображения. Работа регистра яркости в при включенном маскировщике никак не меняется.

Включить и отключить маскировщик можно в любой момент транзакцией в управляющий регистр. Буферы изображения при смене функции не очищаются.
Транзакция для включения маскировщика выглядит следующим образом

```
# С переведенным в высокое значение ALT
spi.writebytes2( \
	[0x0F (яркость)] + \
	list(reversed(np.array([div1 (1й делитель)], dtype=np.uint16).tobytes())) + \
    list(reversed(np.array([div2 (2й делитель)], dtype=np.uint16).tobytes())) + \
    + [0x00, 0x00, 0xFF (вкл. маскировщика)])

```

## Дисплей
Дисплей работает на основе интерфейса Hub75e. Он включает в себя 5 адресующих входов (ABCDE), 3x2 входа цвета (rgb, верх и низ), clk, oe и ltc. В один момент могут быть подсвечены только 2 строчки, в верхней и нижней половине дисплея

FPGA выполняет запись в дисплей по следущему алгоритму:
* На частоте 20мгц:
	* 64 цикла "работы":
		* Сдвинуть регистры цветов строки, установить выводы rgb
		* Подать сигнал clk в противофазе с частотой (во избежание гистерезиса)
	* На последнем цикле "работы":
		* Подать сигнал ltc (запись в строку дисплея) (он перекроется с положительным clk)
	* 255 циклов "паузы":
		* Если N цикла меньше яркости, установить низкий OE (засвечивать строку), иначе потушить
		* Параллельно читать каждые 4 цикла новые значения цветов следующей строки из ОЗУ
	* На последнем цикле "паузы":
		* Прочитать новое значение регистра яркости

Таким образом, фактический fps дисплея составляет 20мгц / 64 + 255 = 62696 кадров в секунду полного обновления дисплея (от предыдущей засветки отдельного пикселя до следующей)

## Корректор
В идеале, изложенная схема должна обеспечивать точное соответствие точек в ОЗУ и на дисплее - но в примененной модели экрана был дефект изготовления, из-за которого матрица сдвинулась на 1 по обоим осям.

Т.е. первым пикселем стал:

OXXX > XXXX\
XXXX > XOXX\
XXXX > XXXX\
XXXX > XXXX

Последняя строка каждой половины дисплея при этом сдвинулась наверх

XXX > XOX\
XXX > XXX\
XOX > XXX\
XXX > XOX\
XXX > XXX\
XOX > XXX

А последний пиксель строки связался с первым следующей и засвечиваются только вместе (2 пикселями управляет 63й бит, 64й не делает ничего)
Засветка одной 1й строки:

XOOO\
OXXX

При засветке предпоследнего ряда связанный пиксель переносится наверх

OXXX\
XXXX\
XOOO

Для устранения описанных дефектов в схему был введен корректор. Это дополнительный, удаляемый блок, преобразующий адреса читаемых данных так, чтобы располоджение данных в ОЗУ всегда точно соответствовало пикселям дисплея. Так как добиться полного соответствия из-за сцепленности пикселей невозможно, этот модуль вырезает все пиксели по краю экрана - они всегда остаются черными, независимо от значений в ОЗУ

# Программируемая часть, RPi

Программируемая часть системы реализована в виде платы Raspberry Pi Zero 2W.
Плата находится под управлением DietPi, подключена к FPGA по USB (для программирования и питания) и SPI, а также присоединена к энкодеру с функцией кнопки.

## Разметка GPIO
* SPI0
	* MOSI -> G10
	* SCLK -> G11
	* CE0 -> D11 (сейчас игнорируется)
* GPIO
	* GPIO25 (SPI Alt) -> D10
	* GPIO22 (pull-up) <- Rotary button
	* GPIO23 (pull-up) <- Rotary A
	* GPIO24 (pull-up) <- Rotary B

## Программирование платы
В ручном режиме осуществляется командой `openFPGALoader -b tangprimer25k ./ao_0.fs`, стирание программы через `openFPGALoader -b tangprimer25k --reset`. Программирование осуществляется при запуске, повторно не требуется

## Python-библиотека
Для работы с устройством предусмотрена Python-библиотека. Для запуска требуется среда с numpy, spidev и RPI.Gpio

В файле ivnd_display класс IVNDDisplay - управляет дисплеем
* При создании сам инициализирует все интерфейсы, при удалении - закрывает их
	* Все методы завершаются с указателями в начальном состоянии: CTRL и IMAGE на первом бите
	* Методы:
		* __clear(fast=True)__ - очищает дисплей и сбрасывает указатели в начальное состояние (из любого состояния). Рекомендуется выполнять после инициализации платы. При `fast=True` нулями заполняется только CTRL, иначе - и IMAGE тоже (перезаписывается при write в любом случае)
		* __set_brightness(value=0:255)__ - устанавливает яркость для следующих команд _render..._ . По сути, setter для свойства brightness, обрезающий значение до валидных (0-255)
		* __render_static()__ - настраивает CTRL для отображения статического отображения. Функции буферов соответствуют их названиям в `write`. Применяется сразу же
		* __render_strobe(fps)__ - вычисляет значения делителей и настраивает CTRL для стробоскопического отображения при данной частоте смены кадров. _fps - частота смены кадров (цикл "темный/светлый и назад" считаются как 2 кадра)_. Применяется сразу же. 
			* Буферы, записанные в write, приобретают функции: image_R - всегда засвечены, image_G - никогда не засвечены, image_B - меняются каждый кадр. Приоритет - never > always > switching
		* __write(image_r, image_g, image_b)__ - записывает содержимое буферов image. Буферы - numpy-ndarray типа np.bool размера 64x64. По умолчанию - заполнены False
	* Последовательность работы:
		```
		dev = IVNDDisplay()
		dev.clear()
		dev.set_brightness(0x0F) # может идти где угодно до render_static
		dev.write(im1, im2, im3) 
		dev.render_static() # может идти перед write
		```
В файле ivnd_patterns методы:
* __ivnd_testcard()__ - рисует настроечную таблицу (красная обводка, зеленые диагонали, синий крест через середины сторон). Возвращает 3 буфера
		* Применение: `dev.write(*ivnd_testcard())
	* __ivnd_number(num1=str, num2=str)__ - рисует 2 цифры на весь экран. Возвразащает 1 буфер
		* Применение: `im = ivnd_number("0", "1"); dev.write(im, im, im)`
    * __ivnd_embed_number(value, frame_a, frame_n)__ - врисовывает маленькое 3-значное число в левый верхний угол для стробоскопа (счетчик FPS). Ничего не возвращает, но изменяет frame_a (always) и frame_n (never)
        * Применение:
        ```	
        sw = ivnd_number("0", "1")
        nev = np.zeros((64, 64), dtype=np.bool)
        alw = np.zeros((64, 64), dtype=np.bool)
        ivnd_embed_number(60, alw, neg) # 60 fps

        dev.write(alw, nev, sw)
        ```
В файле ivnd_rotary - класс для энкодера поворота, пока в разработке